{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACO,aAAa;AACpB;AACA;AACA;AACa,CAAC;AACd;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UCxBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNa;;;AAGb;;AAEA;AACA;AACA;;;;;AAKA;AACA;;;AAGA;;AAEA;;;AAGA;AACA;AACA;;;AAGA;;;;AAIA;;AAEA;;AAEA,IAAI,KAAK;;;;AAIT;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA,IAAI;;AAEJ;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA,IAAI;;AAEJ;;;;;;;;;AASA;;AAEA;;AAEA,UAAU,UAAU;;AAEpB,kBAAkB,KAAK,MAAM,KAAK;;AAElC;AACA;;;;AAIA;;AAEA,UAAU,cAAc;AACxB;;AAEA;;AAEkC;;AAElC,YAAY,qCAAI;;AAEhB,eAAe,yCAAQ,EAAE,MAAM,yCAAQ,CAAC,IAAI;AAC5C,2CAAU;;;AAGV;;AAE+B,CAAC;;AAEhC,oDAAM,G","sources":["webpack:///./js/main.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./js/script.js"],"sourcesContent":["// из main.js будем что-то экспортировать, а в script.js будем импортировать\r\n// При экспорте обязательно должно быть имя. У функций например\r\n\r\nexport let one = 1; // первый способ\r\n\r\n\r\nlet two = 2;\r\nexport {two}; // именнованный синтаксис\r\n\r\n\r\nexport function sayHi() {\r\n    console.log('Hello');\r\n}\r\n\r\n\r\n// в модулях существует экспорт по умолчанию. Он может быть только один. \r\n\r\nexport default function sayBye() { // добавляем default перед названием функции.\r\n    console.log('GoodBye');\r\n}\r\n\r\n\r\n\r\n// в index HTML, можно подключить наши скрипты друг за другом и будет работать без webpack\r\n// но в таком случае мы должны прописать в тэге script   type = 'module'","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","'use strict';\n\n\n// С помощью модулей можно разделить наш код из проекта на разный функционал и поместить в отдельный файл. \n\n// Модуль может быть легко заменен или вообще удален без потери остальной функциональности. \n// Чистота глобального пространства. При создании скрипта мы объявляем переменные которые заносятся в глобальную обл.видимости. Их должно быть как можно меньше\n// Помогают избежать конфликтов с одинаковыми именами. Все имена переменных находятся внутри собственной области видимости модуля. \n\n\n\n\n// Сейчас у нас подключены 2 файла скриптов: основной script.js и доп.библиотека lib.js\n// в доп.библиотеке объявлена переменная app \n\n\n// объявляем такую же переменную в нашем основном скрипте:\n\n// const app = 123;\n\n\n// получаем ошибку Uncaught SyntaxError: Identifier 'app' has already been declared (at script.js:1:1)\n// потому что такая переменная уже объявлена в глобальном пространстве из подключаемой библиотеки.\n// в этом и заключается загрязнение глобального пространства.\n\n\n// создание модулей через нативную реализацию. \n\n\n\n//  1 . Используем анонимную самовызывающуюся функцию\n\n// (function(){\n\n// }()); // вот так это выглядит.\n\n\n\n// const number = 155;\n\n// (function(){ // создаем собственную область видимости\n//     let number = 1;\n//     console.log(number);\n//     console.log(number + 15);\n// }());\n\n// console.log(number);\n\n\n// // 2 Метод с использованием объектного интерфейса. Модуль записываем в переменную и в неё возвращаем методы доступные снаружи.\n\n\n// const user = (function(){\n//         const privat = function() {\n//             console.log('это функция приватная')\n//         };\n\n//         return { // наша анониманая самовызывающая функция, создаёт объект, который возвращает только те методы и свойства, которые нам нужны снаружи.\n//             sayHello: privat\n//         };\n// }());\n\n// user.sayHello();\n\n\n\n\n\n\n\n\n// Модульность. Новый стандарт\n\n// импортируем данные из main.js\n\n// import{one, two} from './main.js';\n\n// console.log(`${one} and ${two} `);\n\n// всё это будет работать, но браузер не умеет собирать в один рабочий скрипт. Нужно обязательно пользоваться сборищиками ( webpack );\n// запускаем npx webpack и получаем bundle.js. Его и запускаем\n\n\n\n// при импорте чего-либо можно сразу переименовать.\n\n// import{one as first} from './main.js';\n// console.log(first);\n\n// в main.js у нас есть 3 сущность. 2 переменные и функция. Чтобы импортировать абсолютно всё и сразу:\n\nimport * as data from './main.js';\n\nconsole.log(data);\n\nconsole.log(`${data.one} and ${data.two}`); // в таком случае обращаемся к нашим импортируемым данным вот так.\ndata.sayHi();\n\n\n// ипорт по умолчанию. В файле main.js была создана функция с ключевым словом default. Чтобы её импортировать:\n\nimport sayBye from './main.js'; // экспортируется напрямую, а не как именнованный объект.\n\nsayBye();"],"names":[],"sourceRoot":""}